"use strict";
/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HumanFormatTransform = void 0;
const tableWritableStream_1 = require("../utils/tableWritableStream");
const i18n_1 = require("../i18n");
const node_stream_1 = require("node:stream");
const utils_1 = require("../utils");
const core_1 = require("@salesforce/core");
const os_1 = require("os");
class HumanFormatTransform extends node_stream_1.Readable {
    testResult;
    detailedCoverage;
    constructor(testResult, detailedCoverage, options) {
        super(options);
        this.testResult = testResult;
        this.detailedCoverage = detailedCoverage;
        this.testResult = testResult;
        this.detailedCoverage ??= false;
    }
    _read() {
        this.format();
        this.push(null); // Indicates end of data
    }
    format() {
        this.formatSummary();
        if (!this.testResult.codecoverage || !this.detailedCoverage) {
            this.formatTestResults();
        }
        if (this.testResult.codecoverage) {
            if (this.detailedCoverage) {
                this.formatDetailedCov();
            }
            this.formatCodeCov();
        }
    }
    formatSummary() {
        const tb = new tableWritableStream_1.TableWriteableStream(this);
        // Summary Table
        const summaryRowArray = [
            {
                name: i18n_1.nls.localize('outcome'),
                value: this.testResult.summary.outcome
            },
            {
                name: i18n_1.nls.localize('testsRan'),
                value: String(this.testResult.summary.testsRan)
            },
            {
                name: i18n_1.nls.localize('passRate'),
                value: this.testResult.summary.passRate
            },
            {
                name: i18n_1.nls.localize('failRate'),
                value: this.testResult.summary.failRate
            },
            {
                name: i18n_1.nls.localize('skipRate'),
                value: this.testResult.summary.skipRate
            },
            {
                name: i18n_1.nls.localize('testRunId'),
                value: this.testResult.summary.testRunId
            },
            {
                name: i18n_1.nls.localize('testExecutionTime'),
                value: `${this.testResult.summary.testExecutionTimeInMs} ms`
            },
            {
                name: i18n_1.nls.localize('orgId'),
                value: this.testResult.summary.orgId
            },
            {
                name: i18n_1.nls.localize('username'),
                value: this.testResult.summary.username
            },
            ...(this.testResult.summary.orgWideCoverage
                ? [
                    {
                        name: i18n_1.nls.localize('orgWideCoverage'),
                        value: String(this.testResult.summary.orgWideCoverage)
                    }
                ]
                : [])
        ];
        tb.createTable(summaryRowArray, [
            {
                key: 'name',
                label: i18n_1.nls.localize('nameColHeader')
            },
            { key: 'value', label: i18n_1.nls.localize('valueColHeader') }
        ], i18n_1.nls.localize('testSummaryHeader'));
    }
    formatTestResults() {
        const tb = new tableWritableStream_1.TableWriteableStream(this);
        const testRowArray = [];
        this.testResult.tests.forEach((elem) => {
            const msg = elem.stackTrace
                ? `${elem.message}\n${elem.stackTrace}`
                : elem.message;
            testRowArray.push({
                name: elem.fullName,
                outcome: elem.outcome,
                msg: elem.message ? msg : '',
                runtime: elem.outcome !== "Fail" /* ApexTestResultOutcome.Fail */ ? `${elem.runTime}` : ''
            });
        });
        this.push(`${os_1.EOL}${os_1.EOL}`);
        tb.createTable(testRowArray, [
            {
                key: 'name',
                label: i18n_1.nls.localize('testNameColHeader')
            },
            { key: 'outcome', label: i18n_1.nls.localize('outcomeColHeader') },
            { key: 'msg', label: i18n_1.nls.localize('msgColHeader') },
            { key: 'runtime', label: i18n_1.nls.localize('runtimeColHeader') }
        ], i18n_1.nls.localize('testResultsHeader'));
    }
    formatDetailedCov() {
        const tb = new tableWritableStream_1.TableWriteableStream(this);
        const testRowArray = [];
        this.testResult.tests.forEach((elem) => {
            const msg = elem.stackTrace
                ? `${elem.message}\n${elem.stackTrace}`
                : elem.message;
            if (elem.perClassCoverage) {
                elem.perClassCoverage.forEach((perClassCov) => {
                    testRowArray.push({
                        name: elem.fullName,
                        coveredClassName: perClassCov.apexClassOrTriggerName,
                        outcome: elem.outcome,
                        coveredClassPercentage: perClassCov.percentage,
                        msg: elem.message ? msg : '',
                        runtime: `${elem.runTime}`
                    });
                });
            }
            else {
                testRowArray.push({
                    name: elem.fullName,
                    coveredClassName: '',
                    outcome: elem.outcome,
                    coveredClassPercentage: '',
                    msg: elem.message ? msg : '',
                    runtime: `${elem.runTime}`
                });
            }
        });
        this.push('\n\n');
        tb.createTable(testRowArray, [
            {
                key: 'name',
                label: i18n_1.nls.localize('testNameColHeader')
            },
            {
                key: 'coveredClassName',
                label: i18n_1.nls.localize('classTestedHeader')
            },
            {
                key: 'outcome',
                label: i18n_1.nls.localize('outcomeColHeader')
            },
            {
                key: 'coveredClassPercentage',
                label: i18n_1.nls.localize('percentColHeader')
            },
            { key: 'msg', label: i18n_1.nls.localize('msgColHeader') },
            { key: 'runtime', label: i18n_1.nls.localize('runtimeColHeader') }
        ], i18n_1.nls.localize('detailedCodeCovHeader', [this.testResult.summary.testRunId]));
    }
    formatCodeCov() {
        const tb = new tableWritableStream_1.TableWriteableStream(this);
        const codeCovRowArray = [];
        this.testResult.codecoverage.forEach((elem) => {
            codeCovRowArray.push({
                name: elem.name,
                percent: elem.percentage,
                uncoveredLines: this.formatUncoveredLines(elem.uncoveredLines)
            });
        });
        this.push('\n\n');
        tb.createTable(codeCovRowArray, [
            {
                key: 'name',
                label: i18n_1.nls.localize('classesColHeader')
            },
            {
                key: 'percent',
                label: i18n_1.nls.localize('percentColHeader')
            },
            {
                key: 'uncoveredLines',
                label: i18n_1.nls.localize('uncoveredLinesColHeader')
            }
        ], i18n_1.nls.localize('codeCovHeader'));
    }
    formatUncoveredLines(uncoveredLines) {
        const arrayLimit = 5;
        if (uncoveredLines.length === 0) {
            return '';
        }
        const limit = uncoveredLines.length > arrayLimit ? arrayLimit : uncoveredLines.length;
        let processedLines = uncoveredLines.slice(0, limit).join(',');
        if (uncoveredLines.length > arrayLimit) {
            processedLines += '...';
        }
        return processedLines;
    }
}
exports.HumanFormatTransform = HumanFormatTransform;
__decorate([
    (0, utils_1.elapsedTime)()
], HumanFormatTransform.prototype, "format", null);
__decorate([
    (0, utils_1.elapsedTime)()
], HumanFormatTransform.prototype, "formatSummary", null);
__decorate([
    (0, utils_1.elapsedTime)()
], HumanFormatTransform.prototype, "formatTestResults", null);
__decorate([
    (0, utils_1.elapsedTime)()
], HumanFormatTransform.prototype, "formatDetailedCov", null);
__decorate([
    (0, utils_1.elapsedTime)('elapsedTime', core_1.LoggerLevel.TRACE)
], HumanFormatTransform.prototype, "formatCodeCov", null);
__decorate([
    (0, utils_1.elapsedTime)('elapsedTime', core_1.LoggerLevel.TRACE)
], HumanFormatTransform.prototype, "formatUncoveredLines", null);
//# sourceMappingURL=humanFormatTransform.js.map