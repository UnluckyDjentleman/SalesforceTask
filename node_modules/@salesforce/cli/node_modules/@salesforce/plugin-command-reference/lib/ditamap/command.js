"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Command = void 0;
const node_path_1 = require("node:path");
const ts_types_1 = require("@salesforce/ts-types");
const utils_1 = require("../utils");
const ditamap_1 = require("./ditamap");
const getDefault = async (flag) => {
    if (!flag) {
        return '';
    }
    if (typeof flag.default === 'function') {
        try {
            const help = await flag.default();
            return help || '';
        }
        catch {
            return '';
        }
    }
    else {
        return flag.default;
    }
};
class Command extends ditamap_1.Ditamap {
    constructor(topic, subtopic, command, commandMeta = {}) {
        const commandWithUnderscores = (0, ts_types_1.ensureString)(command.id).replace(/:/g, '_');
        const filename = ditamap_1.Ditamap.file(`cli_reference_${commandWithUnderscores}`, 'xml');
        super(filename, undefined);
        this.flags = (0, ts_types_1.ensureObject)(command.flags);
        this.commandMeta = commandMeta;
        const summary = (0, utils_1.punctuate)(command.summary);
        this.commandName = command.id.replace(/:/g, (0, ts_types_1.asString)(this.commandMeta.topicSeparator, ':'));
        const description = command.description
            ? (0, utils_1.replaceConfigVariables)(command.description, (0, ts_types_1.asString)(this.commandMeta.binary, 'unknown'), this.commandName)
            : undefined;
        // Help are all the lines after the first line in the description. Before oclif, there was a 'help' property so continue to
        // support that.
        const help = this.formatParagraphs(description);
        let trailblazerCommunityUrl;
        let trailblazerCommunityName;
        if (this.commandMeta.trailblazerCommunityLink) {
            const community = this.commandMeta.trailblazerCommunityLink;
            trailblazerCommunityUrl = community.url ?? 'unknown';
            trailblazerCommunityName = community.name ?? 'unknown';
        }
        const examples = (command.examples ?? []).map((example) => {
            let desc;
            let commands;
            if (typeof example === 'string') {
                const parts = example.split('\n');
                desc = parts.length > 1 ? parts[0] : null;
                commands = parts.length > 1 ? parts.slice(1) : [parts[0]];
            }
            else {
                desc = example.description;
                commands = [example.command];
            }
            return {
                description: (0, utils_1.replaceConfigVariables)(desc ?? '', (0, ts_types_1.asString)(this.commandMeta.binary, 'unknown'), this.commandName),
                commands: commands.map((cmd) => (0, utils_1.replaceConfigVariables)(cmd, (0, ts_types_1.asString)(this.commandMeta.binary, 'unknown'), this.commandName)),
            };
        });
        const state = command.state ?? this.commandMeta.state;
        const commandData = {
            name: this.commandName,
            summary,
            description,
            binary: 'binary' in commandMeta && typeof commandMeta.binary === 'string' ? commandMeta.binary : 'unknown',
            commandWithUnderscores,
            deprecated: command.deprecated ?? state === 'deprecated' ?? false,
            examples,
            help,
            isBetaCommand: state === 'beta',
            isClosedPilotCommand: state === 'closedPilot',
            isOpenPilotCommand: state === 'openPilot',
            trailblazerCommunityName,
            trailblazerCommunityUrl,
        };
        this.data = Object.assign(command, commandData);
        this.destination = (0, node_path_1.join)(ditamap_1.Ditamap.outputDir, topic, filename);
    }
    async getParametersForTemplate(flags) {
        const final = [];
        for (const [flagName, flag] of Object.entries(flags)) {
            if (!flag || flag.hidden)
                continue;
            const description = (0, utils_1.replaceConfigVariables)(Array.isArray(flag?.description) ? flag?.description.join('\n') : flag?.description ?? '', (0, ts_types_1.asString)(this.commandMeta.binary, 'unknown'), this.commandName);
            const entireDescription = flag.summary
                ? `${(0, utils_1.replaceConfigVariables)(flag.summary, (0, ts_types_1.asString)(this.commandMeta.binary, 'unknown'), this.commandName)}\n${description}`
                : description;
            const updated = Object.assign({}, flag, {
                name: flagName,
                description: this.formatParagraphs(entireDescription),
                optional: !flag?.required,
                kind: flag?.kind ?? flag?.type,
                hasValue: flag?.type !== 'boolean',
                // eslint-disable-next-line no-await-in-loop
                defaultFlagValue: await getDefault(flag),
            });
            final.push(updated);
        }
        return final;
    }
    // eslint-disable-next-line class-methods-use-this
    getTemplateFileName() {
        return 'command.hbs';
    }
    async transformToDitamap() {
        const parameters = await this.getParametersForTemplate(this.flags);
        this.data = Object.assign({}, this.data, { parameters });
        return super.transformToDitamap();
    }
}
exports.Command = Command;
//# sourceMappingURL=command.js.map