"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const os = require("node:os");
const node_path_1 = require("node:path");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
// eslint-disable-next-line sf-plugin/no-oclif-flags-command-import
const core_1 = require("@oclif/core");
const core_2 = require("@salesforce/core");
const ts_types_1 = require("@salesforce/ts-types");
const chalk = require("chalk");
const ditamap_1 = require("../../ditamap/ditamap");
const docs_1 = require("../../docs");
const utils_1 = require("../../utils");
// Initialize Messages with the current plugin directory
core_2.Messages.importMessagesDirectory(__dirname);
const messages = core_2.Messages.loadMessages('@salesforce/plugin-command-reference', 'main');
class CommandReferenceGenerate extends sf_plugins_core_1.SfCommand {
    async run() {
        const { flags } = await this.parse(CommandReferenceGenerate);
        ditamap_1.Ditamap.suffix = flags['ditamap-suffix'];
        this.loadedConfig = flags['config-path'] ? await core_1.Config.load((0, node_path_1.resolve)(flags['config-path'])) : this.config;
        let pluginNames;
        if (!flags.plugins && !flags.all) {
            pluginNames = this.loadedConfig
                .getPluginsList()
                .filter((p) => p.type !== 'dev')
                .map((p) => p.name);
        }
        else if (flags.all) {
            const ignore = [
                /@oclif/,
                /@salesforce\/cli/,
                /@salesforce\/plugin-dev/,
                /@salesforce\/plugin-telemetry/,
                /@salesforce\/plugin-command-reference/,
            ];
            pluginNames = this.loadedConfig
                .getPluginsList()
                .map((p) => p.name)
                .filter((p) => !ignore.some((i) => i.test(p)));
        }
        else {
            pluginNames = flags.plugins ?? [];
        }
        if (pluginNames.length === 0) {
            throw new core_2.SfError("No plugins provided. Provide the '--plugins' flag or cd into a directory that contains a valid oclif plugin.");
        }
        const plugins = pluginNames
            .map((name) => name.trim())
            .map((name) => {
            let pluginName = name;
            let plugin = this.getPlugin(pluginName);
            if (!plugin) {
                pluginName = `@salesforce/plugin-${pluginName}`;
                plugin = this.getPlugin(pluginName);
                if (!plugin) {
                    throw new core_2.SfError(`Plugin ${name} or ${pluginName} not found. Is it installed?`);
                }
            }
            return pluginName;
        });
        this.log(`Generating command reference for the following plugins:${plugins
            .map((name) => `${os.EOL}  - ${name}`)
            .join(', ')}`);
        ditamap_1.Ditamap.outputDir = flags['output-dir'];
        ditamap_1.Ditamap.cliVersion = this.loadedConfig.version.replace(/-[0-9a-zA-Z]+$/, '');
        ditamap_1.Ditamap.plugins = this.pluginMap(plugins);
        ditamap_1.Ditamap.pluginVersions = plugins.map((name) => {
            const plugin = this.getPlugin(name);
            const version = plugin?.version;
            if (!version)
                throw new Error(`No version found for plugin ${name}`);
            return { name, version };
        });
        const commands = await this.loadCommands(plugins);
        const topicMetadata = this.loadTopicMetadata(commands);
        const cliMeta = this.loadCliMeta();
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        const docs = new docs_1.Docs(ditamap_1.Ditamap.outputDir, flags.hidden, topicMetadata, cliMeta);
        utils_1.events.on('topic', ({ topic }) => {
            this.log(chalk.green(`Generating topic '${topic}'`));
        });
        const warnings = [];
        utils_1.events.on('warning', (msg) => {
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            process.stderr.write(chalk.yellow(`> ${msg}\n`));
            warnings.push(msg);
        });
        await docs.build(commands);
        this.log(`\nWrote generated doc to ${ditamap_1.Ditamap.outputDir}`);
        if (flags.erroronwarnings && warnings.length > 0) {
            throw new core_2.SfError(`Found ${warnings.length} warnings.`);
        }
        return { warnings };
    }
    pluginMap(plugins) {
        const pluginToParentPlugin = {};
        const resolveChildPlugins = (parentPlugin) => {
            for (const childPlugin of parentPlugin.pjson.oclif.plugins ?? []) {
                pluginToParentPlugin[childPlugin] = parentPlugin.name;
                resolveChildPlugins((0, ts_types_1.ensure)(this.getPlugin(childPlugin)));
            }
        };
        for (const plugin of plugins) {
            const masterPlugin = this.getPlugin(plugin);
            if (!masterPlugin) {
                throw new core_2.SfError(`Plugin ${plugin} not found. Is it installed?`);
            }
            pluginToParentPlugin[masterPlugin.name] = masterPlugin.name;
            resolveChildPlugins(masterPlugin);
        }
        return pluginToParentPlugin;
    }
    getPlugin(pluginName) {
        return this.loadedConfig.plugins.get(pluginName);
    }
    // eslint-disable-next-line class-methods-use-this
    loadTopicMetadata(commands) {
        const finishedPlugins = new Set();
        const output = new Map();
        commands
            .flatMap((commandClass) => {
            // Only load topics for each plugin once
            if (commandClass.pluginName && !finishedPlugins.has(commandClass.pluginName)) {
                if (commandClass.plugin?.pjson.oclif.topics) {
                    finishedPlugins.add(commandClass.plugin.name);
                    return objectTopicsToMap(commandClass.plugin.pjson.oclif.topics);
                }
            }
            return undefined;
        })
            .filter((x) => Boolean(x))
            // we might have the same topic in different plugins, so we need to merge those to avoid Object.fromEntries "last wins" algo
            .map((sfTopics) => {
            sfTopics.forEach((topicInfo, topic) => {
                const existing = output.get(topic);
                if (existing) {
                    // merge the topic objects, merge the subtopic maps
                    output.set(topic, {
                        ...existing,
                        ...topicInfo,
                        // TODO: this might need to be recursive if keys collide at lower levels
                        subtopics: Boolean(existing.subtopics) || Boolean(topicInfo.subtopics)
                            ? new Map([...(existing.subtopics ?? []), ...(topicInfo.subtopics ?? [])])
                            : undefined,
                    });
                }
                else {
                    output.set(topic, topicInfo);
                }
            });
        });
        return output;
    }
    async loadCommands(plugins) {
        const promises = this.loadedConfig.commands
            .filter((cmd) => plugins.includes(cmd.pluginName ?? ''))
            .map(async (cmd) => {
            try {
                let commandClass = await this.loadCommand(cmd);
                let obj = Object.assign({}, cmd, commandClass, {
                    flags: Object.assign({}, cmd.flags, commandClass.flags),
                });
                // Load all properties on all extending classes.
                while (commandClass !== undefined) {
                    commandClass = Reflect.getPrototypeOf(commandClass) || undefined;
                    obj = Object.assign({}, commandClass, obj, {
                        flags: Object.assign({}, commandClass?.flags, obj.flags),
                    });
                }
                return obj;
            }
            catch (error) {
                return cmd;
            }
        });
        const commands = await Promise.all(promises);
        return Array.from(commands
            .reduce((acc, cmd) => {
            acc.set(cmd.id, cmd);
            return acc;
        }, new Map())
            .values());
    }
    // eslint-disable-next-line class-methods-use-this
    async loadCommand(command) {
        // eslint-disable-next-line @typescript-eslint/return-await
        return command.load.constructor.name === 'AsyncFunction' ? await command.load() : command.load();
    }
    loadCliMeta() {
        return {
            binary: this.loadedConfig.pjson.oclif.bin ?? 'sf',
            topicSeparator: this.loadedConfig.pjson.oclif.topicSeparator,
            state: this.loadedConfig.pjson.oclif.state,
        };
    }
}
CommandReferenceGenerate.summary = messages.getMessage('commandSummary');
CommandReferenceGenerate.description = messages.getMessage('commandDescription');
CommandReferenceGenerate.examples = messages.getMessages('examples');
CommandReferenceGenerate.flags = {
    'output-dir': sf_plugins_core_1.Flags.string({
        char: 'd',
        summary: messages.getMessage('flags.output-dir.summary'),
        aliases: ['outputdir'],
        deprecateAliases: true,
        default: './tmp/root',
    }),
    plugins: sf_plugins_core_1.Flags.string({
        char: 'p',
        summary: messages.getMessage('flags.plugins.summary'),
        multiple: true,
        exclusive: ['all'],
    }),
    all: sf_plugins_core_1.Flags.boolean({
        char: 'a',
        summary: messages.getMessage('flags.all.summary'),
        exclusive: ['plugins'],
    }),
    'ditamap-suffix': sf_plugins_core_1.Flags.string({
        char: 's',
        summary: messages.getMessage('flags.ditamap-suffix.summary'),
        default: ditamap_1.Ditamap.SUFFIX,
    }),
    hidden: sf_plugins_core_1.Flags.boolean({ summary: messages.getMessage('flags.hidden.summary') }),
    'error-on-warnings': sf_plugins_core_1.Flags.boolean({
        summary: messages.getMessage('flags.error-on-warnings.summary'),
        aliases: ['erroronwarnings'],
        deprecateAliases: true,
    }),
    'config-path': sf_plugins_core_1.Flags.directory({
        summary: messages.getMessage('flags.config-path.summary'),
        char: 'c',
    }),
};
exports.default = CommandReferenceGenerate;
/** recursively convert the oclif style topics to the command reference topic SfTopicStructure */
const objectTopicsToMap = (pjsonTopics) => new Map(Object.entries(pjsonTopics ?? {}).map(([topic, topicInfo]) => {
    if (topicInfo.subtopics) {
        // TODO
        return [topic, { ...topicInfo, name: topic, subtopics: objectTopicsToMap(topicInfo.subtopics) }];
    }
    return [topic, { ...topicInfo, name: topic, subtopics: undefined }];
}));
//# sourceMappingURL=generate.js.map