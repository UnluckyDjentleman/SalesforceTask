/*
 * Copyright (c) 2023, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
import { Duration } from '@salesforce/kit';
import { capitalCase } from 'change-case';
import { Messages } from '@salesforce/core';
import { getResultMessage } from './reporters/reporters.js';
Messages.importMessagesDirectoryFromMetaUrl(import.meta.url);
const messages = Messages.loadMessages('@salesforce/plugin-data', 'bulk.base.command');
export const setupLifecycleListeners = ({ job, cache, username, apiVersion, cmd, isAsync, endWaitTime, }) => {
    // the event emitted by jsforce's polling function
    job.on('inProgress', (jobInfo) => {
        cmd.spinner.status = formatSpinnerProgress(isAsync, endWaitTime, jobInfo);
    });
    // the event emitted other places in the plugin
    job.on('jobProgress', () => {
        const handler = async () => {
            const jobInfo = await job.check();
            cmd.spinner.status = formatSpinnerProgress(isAsync, endWaitTime, jobInfo);
        };
        handler().catch((err) => eventListenerErrorHandler(err));
    });
    job.on('failed', throwAndStopSpinner(cmd.spinner));
    job.on('error', throwAndStopSpinner(cmd.spinner));
    job.once('jobTimeout', () => {
        const handler = async () => {
            await cache?.createCacheEntryForRequest(job.id ?? '', username, apiVersion);
            displayBulkV2Result({ jobInfo: await job.check(), username, isAsync, cmd });
        };
        handler().catch((err) => eventListenerErrorHandler(err));
    });
};
export const displayBulkV2Result = ({ jobInfo, isAsync, cmd, username = 'unspecified user', }) => {
    if (isAsync && jobInfo.state !== 'JobComplete' && jobInfo.state !== 'Failed') {
        cmd.logSuccess(messages.getMessage('success', [jobInfo.operation, jobInfo.id]));
        cmd.info(messages.getMessage('checkStatus', [jobInfo.operation, jobInfo.id, username]));
    }
    else {
        cmd.log();
        cmd.info(getResultMessage(jobInfo));
        if ((jobInfo.numberRecordsFailed ?? 0) > 0 || jobInfo.state === 'Failed') {
            cmd.info(messages.getMessage('checkJobViaUi', [username, jobInfo.id]));
            process.exitCode = 1;
        }
        if (jobInfo.state === 'InProgress' || jobInfo.state === 'Open') {
            cmd.info(messages.getMessage('checkStatus', [jobInfo.operation, jobInfo.id, username]));
        }
        if (jobInfo.state === 'Failed') {
            throw messages.createError('bulkJobFailed', [jobInfo.id]).setData(jobInfo);
        }
    }
};
const eventListenerErrorHandler = (err) => {
    throw err instanceof Error || typeof err === 'string' ? err : JSON.stringify(err);
};
const throwAndStopSpinner = (spinner) => (err) => {
    try {
        throw err;
    }
    finally {
        spinner.stop();
    }
};
export const getRemainingTimeStatus = ({ isAsync, endWaitTime }) => isAsync ? '' : messages.getMessage('remainingTimeStatus', [Duration.milliseconds(endWaitTime - Date.now()).minutes]);
const formatSpinnerProgress = (isAsync, endWaitTime, jobInfo) => `${getRemainingTimeStatus({
    isAsync,
    endWaitTime,
})} | ${getStage(jobInfo.state)} | ${getRemainingRecordsStatus(jobInfo)}`;
const getStage = (state) => ` Stage: ${capitalCase(state)}`;
const getRemainingRecordsStatus = (jobInfo) => {
    const numberRecordsProcessed = jobInfo.numberRecordsProcessed ?? 0;
    const numberRecordsFailed = jobInfo.numberRecordsFailed ?? 0;
    const numberRecordSucceeded = numberRecordsProcessed - numberRecordsFailed;
    // the leading space is intentional
    return ` ${messages.getMessage('remainingRecordsStatus', [
        numberRecordsProcessed,
        numberRecordSucceeded,
        numberRecordsFailed,
    ])}`;
};
//# sourceMappingURL=BulkBaseCommand.js.map